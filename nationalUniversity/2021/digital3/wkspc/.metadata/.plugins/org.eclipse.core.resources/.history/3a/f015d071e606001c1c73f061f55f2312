/*
===============================================================================
 Name        : pract1.c
 Author      : $(author)
 Version     :
 Copyright   : $(copyright)
 Description : main definition
===============================================================================
*/

#ifdef __USE_CMSIS
#include "LPC17xx.h"
#endif

#include <cr_section_macros.h>

#include "myGpio.h"

/*
 * Proceso
 */
int main(void) {

	/*
	 * Init core
	 */
	SystemInit();

	//gpio a digital output
	cfgGpio(0, 22, 'o', 'x');
	cfgGpio(3, 25, 'o', 'x');
	cfgGpio(3, 26, 'o', 'x');

	//led off
	setGpio(0, 22, 1);
	setGpio(3, 25, 1);
	setGpio(3, 26, 1);

	// Force the counter to be placed into memory
	volatile static unsigned int i = 0 ;

	// Blink led
	while(1) {

		//led R
		setGpio(0, 22, 0);
		setGpio(3, 25, 1);
		setGpio(3, 26, 1);

		//delay
		while(i!=1024*1000) i++;
		i=0;

		//led G
		setGpio(0, 22, 1);
		setGpio(3, 25, 0);

		//delay
		while(i!=1024*1000) i++;
		i=0;

		//led B
		setGpio(3, 25, 1);
		setGpio(3, 26, 0);

		//delay
		while(i!=1024*1000) i++;
		i=0;

		//led RG
		setGpio(3, 26, 1);
		setGpio(0, 22, 0);
		setGpio(3, 25, 0);

		//delay
		while(i!=1024*1000) i++;
		i=0;

		//led GB
		setGpio(0, 22, 1);
		setGpio(3, 26, 0);

		//delay
		while(i!=1024*1000) i++;
		i=0;

		//led BR
		setGpio(3, 25, 1);
		setGpio(0, 22, 0);

		//delay
		while(i!=1024*1000) i++;
		i=0;

		//led RGB
		setGpio(0, 22, 0);
		setGpio(3, 25, 0);
		setGpio(3, 26, 0);

		//delay
		while(i!=1024*1000) i++;
		i=0;

		//led OFF
		setGpio(0, 22, 1);
		setGpio(3, 25, 1);
		setGpio(3, 26, 1);

		//delay
		while(i!=1024*1000) i++;
		i=0;
	}

    return 0;
}

///*
// * Configurar gpio
// * Para la placa interesan los Gpio: 0, 1, 2L, 3H, 4H
// * >> Por default el pin es: salida, float
// */
//unsigned char cfgGpio(unsigned char gpio,unsigned char pin,char dir,char pullmode){
//
//	//seleccionar registros correctos de PINCON
//	unsigned int *ppPinsel=PINSELBASE;
//	unsigned int *ppPinmode=PINMODEBASE;
//
//	switch(gpio){
//		//para gpio2-L solo vale PINSEL/MODE2
//		case 2:
//			ppPinsel+=(2*gpio);
//			ppPinmode+=(2*gpio);
//			break;
//
//		//para gpio3-H solo vale PINSEL/MODE7
//		case 3:
//			ppPinsel+=(2*gpio + 1);
//			ppPinmode+=(2*gpio + 1);
//			break;
//
//		//para gpio4-H solo vale PINSEL/MODE9
//		case 4:
//			ppPinsel+=(2*gpio + 1);
//			ppPinmode+=(2*gpio + 1);
//			break;
//
//		//para los demas vale PINSEL/MODE(x) si pin<16, sino PINSEL/MODE(x+1)
//		default:
//			ppPinsel+=(2*gpio + pin>15);
//			ppPinmode+=(2*gpio + pin>15);
//			break;
//	}
//
//	/*
//	 * Funcion gpio digital
//	 */
//	*ppPinsel&=~(0b11<<(2*pin-32*(pin>15)));
//
//	/*
//	 * Pull mode (default: float)
//	 */
//	//pullup
//	if(pullmode=='u'){
//		*ppPinmode&=~(0b11<<(2*pin-32*(pin>15)));
//	}
//	//pulldown
//	else if(pullmode=='d'){
//		*ppPinmode|=(0b11<<(2*pin-32*(pin>15)));
//	}
//	//float
//	else{
//		*ppPinmode|=(0b10<<(2*pin-32*(pin>15)));
//	}
//
//	//seleccionar registros correctos de GPIO, van saltando de a 32 bytes
//	LPC_GPIO_TypeDef* insGpio=(LPC_GPIO_TypeDef *)(LPC_GPIO_BASE+(32*gpio));
//
//	/*
//	 * Data direction (default: salida)
//	 */
//	//input
//	if(dir=='i'){
//		insGpio->FIODIR&=~(1<<pin);
//	}
//	//output
//	else{
//		insGpio->FIODIR|=(1<<pin);
//	}
//
//	return 0;
//}
//
///*
// * Retornar valor del pin p en el Gpio x (Gx.p)
// */
//unsigned char getGpio(unsigned char gpio,unsigned char pin){
//
//	//seleccionar registros correctos de GPIO, van saltando de a 32 bytes
//	LPC_GPIO_TypeDef* insGpio=(LPC_GPIO_TypeDef *)(LPC_GPIO_BASE+(32*gpio));
//
//	//guardar mascara actual
//	unsigned int tmpMask=insGpio->FIOMASK;
//
//	//crear mascara para ver solo el pin pedido
//	insGpio->FIOMASK|=~(1<<pin);
//
//	//leer valor por fiopin
//	unsigned char stat=(insGpio->FIOPIN)>>pin;
//
//	//restaurar mascara anterior
//	insGpio->FIOMASK=tmpMask;
//
//	return stat;
//}
//
///*
// * Setear al valor val del pin p en el Gpio x (Gx.p = val)
// * >> Por default el pin es: 1
// */
//void setGpio(unsigned char gpio,unsigned char pin,unsigned char val){
//
//	//seleccionar registros correctos de GPIO, van saltando de a 32 bytes
//	LPC_GPIO_TypeDef* insGpio=(LPC_GPIO_TypeDef *)(LPC_GPIO_BASE+(32*gpio));
//
//	/*
//	 * Escribir pin (default: 1)
//	 */
//	if(val==0){
//		insGpio->FIOPIN&=~(1<<pin);
//	}
//	else{
//		insGpio->FIOPIN|=(1<<pin);
//	}
//
//	return;
//}

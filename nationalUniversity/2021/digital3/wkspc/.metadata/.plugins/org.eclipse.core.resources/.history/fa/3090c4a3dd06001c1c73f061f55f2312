/*
===============================================================================
 Name        : pract1.c
 Author      : $(author)
 Version     :
 Copyright   : $(copyright)
 Description : main definition
===============================================================================
*/

#ifdef __USE_CMSIS
#include "LPC17xx.h"
#endif

#include <cr_section_macros.h>

// Macros
#define PINSELBASE 	(unsigned int *)(0x4002C000)
#define PINMODEBASE (unsigned int *)(0x4002C040)

// Prototipos
unsigned char cfgGpio(unsigned char gpio,unsigned char pin,char dir,char pullmode);
unsigned char getGpio(unsigned char gpio,unsigned char pin);
void setGpio(unsigned char gpio,unsigned char pin,unsigned char val);

int main(void) {

	//core init
	SystemInit();

	//gpio0 a digital output
	cfgGpio(0, 22, 'o', 'x');

	// Force the counter to be placed into memory
	volatile static unsigned int i = 0 ;

	//pin status
	unsigned char aux0;

	// Blink led
	while(1) {
		//pin off, led on
		setGpio(0, 22, 0);

		//valor del pin
		aux0=getGpio(0, 22);

		//delay
		while(i!=1024*2000) i++;
		i=0;

		//pin on, led off
		//ssGpio0->FIOSET=(1<<22);
		//LPC_GPIO0->FIOSET=(1<<22);
		setGpio(0, 22, 1);

		//valor del pin
		aux0=getGpio(0, 22);

		//delay
		while(i!=1024*2000) i++;
		i=0;

	}

    return 0;
}

/*
 * Configurar gpio
 * Para la placa interesan los Gpio: 0, 1, 2L, 3H, 4H
 */
unsigned char cfgGpio(unsigned char gpio,unsigned char pin,char dir,char pullmode){

	//seleccionar registros correctos de PINCON
	unsigned int *ppPinsel=PINSELBASE;
	unsigned int *ppPinmode=PINMODEBASE;

	switch(gpio){
		//para gpio2-L solo vale PINSEL/MODE2
		case 2:
			ppPinsel+=(2*gpio);
			ppPinmode+=(2*gpio);
			break;

		//para gpio3-H solo vale PINSEL/MODE7
		case 3:
			ppPinsel+=(2*gpio + 1);
			ppPinmode+=(2*gpio + 1);
			break;

		//para gpio4-H solo vale PINSEL/MODE9
		case 4:
			ppPinsel+=(2*gpio + 1);
			ppPinmode+=(2*gpio + 1);
			break;

		//para los demas vale PINSEL/MODE(x) si pin<16, sino PINSEL/MODE(x+1)
		default:
			ppPinsel+=(2*gpio + pin>15);
			ppPinmode+=(2*gpio + pin>15);
			break;
	}

	/*
	 * Funcion gpio digital
	 */
	*ppPinsel&=~(0b11<<(2*pin-32*(pin>15)));

	/*
	 * Pull mode (default: float)
	 */
	//pullup
	if(pullmode=='u'){
		*ppPinmode&=~(0b11<<(2*pin-32*(pin>15)));
	}
	//pulldown
	else if(pullmode=='d'){
		*ppPinmode|=(0b11<<(2*pin-32*(pin>15)));
	}
	//float
	else{
		*ppPinmode|=(0b10<<(2*pin-32*(pin>15)));
	}

	//seleccionar registros correctos de GPIO, van saltando de a 32 bytes
	LPC_GPIO_TypeDef* insGpio=(LPC_GPIO_TypeDef *)(LPC_GPIO_BASE+(32*gpio));

	/*
	 * Data direction (default: salida)
	 */
	//input
	if(dir=='i'){
		insGpio->FIODIR&=~(1<<pin);
	}
	//output
	else{
		insGpio->FIODIR|=(1<<pin);
	}

	return 0;
}

///*
// * Configurar gpio
// */
//unsigned char cfgGpio(char gpio,short int pin,char dir,char pullmode){
//	//seleccionar registros por gpio
//	switch(gpio){
//		//gpio 0
//		case 0:
//			//parte baja
//			if(pin<16){
//				/* Modo gpio
//				 * 1<<r --> bit r=1, 1+N<<r --> bit r, y N bits siguientes = 1
//				 * Si pin < 15 --> desplaza 2*pin bits, sino --> 2*pin-32 bits
//				 */
//				LPC_PINCON->PINSEL0&=~(0b11<<(2*pin));
//
//				/*
//				 * Pullmode
//				 */
//				//pull-up
//				if(pullmode=='u') LPC_PINCON->PINMODE0&=~(0b11<<(2*pin));
//				//pull-down
//				else if(pullmode=='d') LPC_PINCON->PINMODE0|=(0b11<<(2*pin));
//				//flotante (default)
//				else LPC_PINCON->PINMODE0|=(0b10<<(2*pin));
//			}
//
//			//parte alta
//			else{
//				//modo gpio
//				LPC_PINCON->PINSEL1&=~(0b11<<(2*pin-32));
//
//				//pullmode
//				//pull-up
//				if(pullmode=='u') LPC_PINCON->PINMODE1&=~(0b11<<(2*pin));
//				//pull-down
//				else if(pullmode=='d') LPC_PINCON->PINMODE1|=(0b11<<(2*pin));
//				//flotante (default)
//				else LPC_PINCON->PINMODE1|=(0b10<<(2*pin));
//			}
//
//			/*
//			 * Direccion
//			 */
//			//input
//			if(dir=='i') LPC_GPIO0->FIODIR|=(0<<pin);
//			//output (default)
//			else LPC_GPIO0->FIODIR|=(1<<pin);
//
//			break;
//
//			///////////////////////////////////////////////////////////////////////
//
//		//gpio 1
//		case 1:
//			//parte baja
//			if(pin<16){
//				/* Modo gpio
//				 * 1<<r --> bit r=1, 1+N<<r --> bit r, y N bits siguientes = 1
//				 * Si pin < 15 --> desplaza 2*pin bits, sino --> 2*pin-32 bits
//				 */
//				LPC_PINCON->PINSEL2&=~(0b11<<(2*pin));
//
//				/*
//				 * Pullmode
//				 */
//				//pull-up
//				if(pullmode=='u') LPC_PINCON->PINMODE2&=~(0b11<<(2*pin));
//				//pull-down
//				else if(pullmode=='d') LPC_PINCON->PINMODE2|=(0b11<<(2*pin));
//				//flotante (default)
//				else LPC_PINCON->PINMODE2|=(0b10<<(2*pin));
//			}
//
//			//parte alta
//			else{
//				//modo gpio
//				LPC_PINCON->PINSEL3&=~(0b11<<(2*pin-32));
//
//				//pullmode
//				//pull-up
//				if(pullmode=='u') LPC_PINCON->PINMODE3&=~(0b11<<(2*pin));
//				//pull-down
//				else if(pullmode=='d') LPC_PINCON->PINMODE3|=(0b11<<(2*pin));
//				//flotante (default)
//				else LPC_PINCON->PINMODE3|=(0b10<<(2*pin));
//			}
//
//			/*
//			 * Direccion
//			 */
//			//input
//			if(dir=='i') LPC_GPIO1->FIODIR|=(0<<pin);
//			//output (default)
//			else LPC_GPIO1->FIODIR|=(1<<pin);
//
//			break;
//
//			///////////////////////////////////////////////////////////////////////
//
//			//gpio 2
//			case 2:
//				//parte baja
//				if(pin<16){
//					/* Modo gpio
//					 * 1<<r --> bit r=1, 1+N<<r --> bit r, y N bits siguientes = 1
//					 * Si pin < 15 --> desplaza 2*pin bits, sino --> 2*pin-32 bits
//					 */
//					LPC_PINCON->PINSEL4&=~(0b11<<(2*pin));
//
//					/*
//					 * Pullmode
//					 */
//					//pull-up
//					if(pullmode=='u') LPC_PINCON->PINMODE4&=~(0b11<<(2*pin));
//					//pull-down
//					else if(pullmode=='d') LPC_PINCON->PINMODE4|=(0b11<<(2*pin));
//					//flotante (default)
//					else LPC_PINCON->PINMODE4|=(0b10<<(2*pin));
//				}
//
//				//parte alta
//				else{
//					//modo gpio
//					LPC_PINCON->PINSEL5&=~(0b11<<(2*pin-32));
//
//					//pullmode
//					//pull-up
//					if(pullmode=='u') LPC_PINCON->PINMODE5&=~(0b11<<(2*pin));
//					//pull-down
//					else if(pullmode=='d') LPC_PINCON->PINMODE5|=(0b11<<(2*pin));
//					//flotante (default)
//					else LPC_PINCON->PINMODE5|=(0b10<<(2*pin));
//				}
//
//				/*
//				 * Direccion
//				 */
//				//input
//				if(dir=='i') LPC_GPIO2->FIODIR|=(0<<pin);
//				//output (default)
//				else LPC_GPIO2->FIODIR|=(1<<pin);
//
//				break;
//
//	}
//
//	return 1;
//}

/*
 * Retornar valor del pin p en el Gpio x (Gx.p)
 */
unsigned char getGpio(unsigned char gpio,unsigned char pin){

	//seleccionar registros correctos de GPIO, van saltando de a 32 bytes
	LPC_GPIO_TypeDef* insGpio=(LPC_GPIO_TypeDef *)(LPC_GPIO_BASE+(32*gpio));

	//guardar mascara actual
	unsigned int tmpMask=insGpio->FIOMASK;

	//crear mascara para ver solo el pin pedido
	insGpio->FIOMASK|=~(1<<pin);

	//leer valor por fiopin
	unsigned char stat=(insGpio->FIOPIN)>>pin;

	//restaurar mascara anterior
	insGpio->FIOMASK=tmpMask;

	return stat;
}

/*
 * Setear al valor val del pin p en el Gpio x (Gx.p = val)
 */
void setGpio(unsigned char gpio,unsigned char pin,unsigned char val){

	//seleccionar registros correctos de GPIO, van saltando de a 32 bytes
	LPC_GPIO_TypeDef* insGpio=(LPC_GPIO_TypeDef *)(LPC_GPIO_BASE+(32*gpio));

	/*
	 * Escribir pin (default: 1)
	 */
	if(val==0){
		insGpio->FIOPIN&=~(1<<pin);
	}
	else{
		insGpio->FIOPIN|=(1<<pin);
	}

	return;
}
